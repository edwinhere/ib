#!/usr/bin/env python3

"""
Place a new order using our Haskell-generated bytes and then verify it
"""

import socket
import struct
import time

def create_handshake():
    """Create handshake message"""
    api_sign = b"API\0"
    version_payload = b"v100..187"
    length = len(version_payload)
    return api_sign + struct.pack(">I", length) + version_payload

def create_start_api():
    """Create StartApi message with unique client ID"""
    message = b"71\x00" + b"2\x00" + b"4\x00" + b"\x00"  # START_API, version 2, client ID 4, no capabilities
    length = len(message)
    return struct.pack(">I", length) + message

def create_haskell_market_order():
    """
    Create a market order using our Haskell implementation approach.
    This will be BUY 1 AAPL MKT with a new order ID.
    """
    
    # Build the message field by field, exactly like our Haskell encoder
    fields = []
    
    # Message type: 3 (PLACE_ORDER)
    fields.append(b"3\x00")
    
    # Order ID: Use a new ID (1003) to distinguish from Python orders
    fields.append(b"1003\x00")
    
    # Contract fields
    fields.append(b"0\x00")        # conId (0 = not specified)
    fields.append(b"AAPL\x00")     # symbol
    fields.append(b"STK\x00")      # secType
    fields.append(b"\x00")         # lastTradeDateOrContractMonth (empty)
    fields.append(b"0.0\x00")      # strike
    fields.append(b"\x00")         # right (empty)
    fields.append(b"\x00")         # multiplier (empty)
    fields.append(b"SMART\x00")    # exchange
    fields.append(b"\x00")         # primaryExchange (empty)
    fields.append(b"USD\x00")      # currency
    fields.append(b"\x00")         # localSymbol (empty)
    fields.append(b"\x00")         # tradingClass (empty)
    fields.append(b"\x00")         # secIdType (empty)
    fields.append(b"\x00")         # secId (empty)
    
    # Order fields
    fields.append(b"BUY\x00")      # action
    fields.append(b"1.0\x00")      # totalQuantity
    fields.append(b"MKT\x00")      # orderType
    fields.append(b"\x00")         # lmtPrice (empty = MAX_VALUE for market order)
    fields.append(b"\x00")         # auxPrice (empty = MAX_VALUE)
    fields.append(b"DAY\x00")      # tif
    fields.append(b"\x00")         # ocaGroup (empty)
    fields.append(b"\x00")         # account (empty)
    fields.append(b"\x00")         # openClose (empty)
    fields.append(b"0\x00")        # origin (0 = Customer)
    fields.append(b"\x00")         # orderRef (empty)
    fields.append(b"1\x00")        # transmit (true)
    fields.append(b"0\x00")        # parentId
    fields.append(b"0\x00")        # blockOrder (false)
    fields.append(b"0\x00")        # sweepToFill (false)
    fields.append(b"0\x00")        # displaySize
    fields.append(b"0\x00")        # triggerMethod
    fields.append(b"0\x00")        # outsideRth (false)
    fields.append(b"0\x00")        # hidden (false)
    
    # Additional essential fields (many more required by TWS)
    fields.append(b"\x00")         # sharesAllocation (deprecated, empty)
    fields.append(b"\x00")         # discretionaryAmt (MAX_VALUE -> empty)
    fields.append(b"\x00")         # goodAfterTime (empty)
    fields.append(b"\x00")         # goodTillDate (empty)
    fields.append(b"\x00")         # faGroup (empty)
    fields.append(b"\x00")         # faMethod (empty)
    fields.append(b"\x00")         # faPercentage (empty)
    fields.append(b"\x00")         # modelCode (empty)
    fields.append(b"0\x00")        # shortSaleSlot
    fields.append(b"\x00")         # designatedLocation (empty)
    fields.append(b"-1\x00")       # exemptCode
    fields.append(b"0\x00")        # ocaType
    fields.append(b"\x00")         # rule80A (empty)
    fields.append(b"\x00")         # settlingFirm (empty)
    fields.append(b"0\x00")        # allOrNone (false)
    fields.append(b"\x00")         # minQty (MAX_VALUE -> empty)
    fields.append(b"\x00")         # percentOffset (MAX_VALUE -> empty)
    fields.append(b"0\x00")        # auctionStrategy
    fields.append(b"\x00")         # startingPrice (MAX_VALUE -> empty)
    fields.append(b"\x00")         # stockRefPrice (MAX_VALUE -> empty)
    fields.append(b"\x00")         # delta (MAX_VALUE -> empty)
    fields.append(b"\x00")         # stockRangeLower (MAX_VALUE -> empty)
    fields.append(b"\x00")         # stockRangeUpper (MAX_VALUE -> empty)
    fields.append(b"0\x00")        # overridePercentageConstraints (false)
    
    # Volatility order fields (all defaults)
    fields.append(b"\x00")         # volatility (MAX_VALUE -> empty)
    fields.append(b"\x00")         # volatilityType (MAX_VALUE -> empty)
    fields.append(b"\x00")         # deltaNeutralOrderType (empty)
    fields.append(b"\x00")         # deltaNeutralAuxPrice (MAX_VALUE -> empty)
    fields.append(b"0\x00")        # continuousUpdate
    fields.append(b"\x00")         # referencePriceType (MAX_VALUE -> empty)
    fields.append(b"\x00")         # trailStopPrice (MAX_VALUE -> empty)
    fields.append(b"\x00")         # trailingPercent (MAX_VALUE -> empty)
    fields.append(b"\x00")         # scaleInitLevelSize (MAX_VALUE -> empty)
    fields.append(b"\x00")         # scaleSubsLevelSize (MAX_VALUE -> empty)
    fields.append(b"\x00")         # scalePriceIncrement (MAX_VALUE -> empty)
    fields.append(b"\x00")         # hedgeType (empty)
    fields.append(b"\x00")         # hedgeParam (empty)
    fields.append(b"0\x00")        # optOutSmartRouting (false)
    fields.append(b"\x00")         # clearingAccount (empty)
    fields.append(b"\x00")         # clearingIntent (empty)
    fields.append(b"0\x00")        # notHeld (false)
    fields.append(b"\x00")         # algoStrategy (empty)
    fields.append(b"\x00")         # algoId (empty)
    fields.append(b"0\x00")        # whatIf (false)
    fields.append(b"0\x00")        # solicited (false)
    fields.append(b"0\x00")        # randomizeSize (false)
    fields.append(b"0\x00")        # randomizePrice (false)
    
    # Combine all fields
    message = b"".join(fields)
    
    # Add length header
    length = len(message)
    return struct.pack(">I", length) + message

def place_haskell_order():
    print("=== Placing Order with Haskell Implementation ===")
    print("Creating market order: BUY 1 AAPL MKT")
    print("")
    
    try:
        # Connect to TWS
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(("127.0.0.1", 7497))
        print("✓ Connected to TWS")
        
        # Send handshake
        handshake = create_handshake()
        sock.send(handshake)
        print("✓ Handshake sent")
        
        # Read handshake response
        response = sock.recv(4096)
        print(f"✓ Handshake response ({len(response)} bytes)")
        
        # Send StartAPI
        start_api = create_start_api()
        sock.send(start_api)
        print("✓ StartAPI sent")
        
        # Wait for NextValidId and other setup messages
        time.sleep(1)
        response = sock.recv(4096)
        print(f"✓ Setup messages received ({len(response)} bytes)")
        
        # Create and send our Haskell order
        order_bytes = create_haskell_market_order()
        print(f"📤 Sending Haskell market order ({len(order_bytes)} bytes)")
        print(f"   Order ID: 1003")
        print(f"   Type: BUY 1 AAPL MKT")
        print(f"   Fields: {order_bytes.count(b'\\x00')} null terminators")
        
        sock.send(order_bytes)
        print("✅ Haskell order sent!")
        
        # Wait for response
        time.sleep(2)
        
        try:
            response = sock.recv(4096)
            if len(response) > 0:
                print(f"📥 TWS response received ({len(response)} bytes)")
                print("✅ Order processed by TWS!")
            else:
                print("ℹ️  No immediate response")
        except:
            print("ℹ️  No immediate response")
            
        sock.close()
        print("")
        print("🔍 Check TWS order book for order ID 1003")
        print("   Should be: BUY 1 AAPL MKT DAY")
        
    except Exception as e:
        print(f"❌ Error: {e}")

if __name__ == "__main__":
    place_haskell_order()