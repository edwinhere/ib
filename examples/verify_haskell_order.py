#!/usr/bin/env python3

"""
This script demonstrates that our Haskell implementation generates
the correct wire format by manually sending the bytes we generate.
"""

import socket
import struct
import time

def create_haskell_order_bytes():
    """
    This generates the exact same bytes that our Haskell implementation produces
    for: BUY 1 AAPL MKT order with ID 1002
    """
    
    # This is the output from our Haskell HexDumpOrder.hs program
    # It represents: BUY 1 AAPL MKT DAY transmit=true
    hex_string = """
    00 00 00 8d 33 00 31 30 30 32 00 30 00 41 41 50
    4c 00 53 54 4b 00 00 30 2e 30 00 00 00 53 4d 41
    52 54 00 00 55 53 44 00 00 00 00 00 42 55 59 00
    31 2e 30 00 4d 4b 54 00 00 00 44 41 59 00 00 00
    00 30 00 00 31 00 30 00 30 00 30 00 30 00 30 00
    30 00 30 00 00 00 00 00 00 00 00 00 30 00 00 2d
    31 00 30 00 00 00 30 00 00 00 30 00 00 00 00 00
    00 30 00 00 00 00 00 30 00 00 00 00 00 00 00 00
    00 30 00 00 00 30 00 00 00 30 00 30 00 30 00 30
    00
    """
    
    # Convert hex string to bytes
    hex_clean = hex_string.replace('\n', '').replace(' ', '')
    return bytes.fromhex(hex_clean)

def create_handshake():
    """Create handshake message"""
    api_sign = b"API\0"
    version_payload = b"v100..187"
    length = len(version_payload)
    return api_sign + struct.pack(">I", length) + version_payload

def create_start_api():
    """Create StartApi message"""
    message = b"71\x00" + b"2\x00" + b"2\x00" + b"\x00"  # START_API, version 2, client ID 2, no capabilities
    length = len(message)
    return struct.pack(">I", length) + message

def test_haskell_order():
    print("=== Testing Haskell PlaceOrder Implementation ===")
    print("Sending order bytes generated by our Haskell code...")
    print("")
    
    try:
        # Connect to TWS
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(("127.0.0.1", 7497))
        print("âœ“ Connected to TWS")
        
        # Send handshake
        handshake = create_handshake()
        sock.send(handshake)
        print("âœ“ Handshake sent")
        
        # Read handshake response
        response = sock.recv(4096)
        print(f"âœ“ Handshake response received ({len(response)} bytes)")
        
        # Send StartAPI
        start_api = create_start_api()
        sock.send(start_api)
        print("âœ“ StartAPI sent")
        
        # Wait a bit for responses
        time.sleep(1)
        
        # Read any responses (should include NextValidId)
        try:
            response = sock.recv(4096)
            print(f"âœ“ Received response ({len(response)} bytes)")
        except:
            pass
        
        # Now send our Haskell-generated order bytes
        order_bytes = create_haskell_order_bytes()
        print(f"ğŸ“¤ Sending Haskell order ({len(order_bytes)} bytes)")
        print(f"   First 32 bytes: {order_bytes[:32].hex()}")
        
        sock.send(order_bytes)
        print("âœ… Haskell order sent!")
        
        # Wait for response
        time.sleep(2)
        
        try:
            response = sock.recv(4096)
            print(f"ğŸ“¥ Order response received ({len(response)} bytes)")
            if len(response) > 0:
                print("âœ… TWS processed our Haskell order!")
                print("ğŸ” Check TWS - you should see a new AAPL order")
            else:
                print("â„¹ï¸  No immediate response, but order may still be processed")
        except:
            print("â„¹ï¸  No immediate response, but order may still be processed")
            
        sock.close()
        
    except Exception as e:
        print(f"âŒ Error: {e}")
        print("ğŸ’¡ Make sure TWS is still running")

if __name__ == "__main__":
    test_haskell_order()